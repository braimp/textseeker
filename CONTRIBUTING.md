Standard Practices
==================

I have chosen several standard practices in those packages I now happen to use **Qt** and **qmake** for, to facilitate development, to better support distributed releases, and to provide better testability of my software.  

In standardizing and documenting my own practices, I believe it is important not just for the code to be free, but also how to build a given project and manage the software lifecycle as well.  There is no reason why one cannot produce high quality enterprise ready free as in freedom software, and many reasons why free software can and should produce better results.

Copyright Assignment
====================

What makes a copyleft license stronger than a generic free software license like the BSD or MIT license is that the freedom it offers to all downstream users cannot be terminated by any intermediary party, and is actively defendable in court.  This requires a copyright holder (or holders) of record with explicit right to do so.  Tycho Softworks is the copyright holder for this package and so we desire all significant contributions to include explicit copyright assignment.

Build Types
===========

My qmake **release** builds generally are created with debug symbols to facilitate reporting of crash dumps.  Generally they are stripped before shipping binary packages, so I can symbolicated later, such as with a Google handbrake server.  However, I also have a special make target for creating release builds, **archive**, which produces a build/archive that can be used to produce stand-alone builds that can be tested locally or handed out to external testers.  I also have a special make target, **publish**, to produce source archives and release builds for external distribution.

Generally I assume qmake **debug** builds are to be primarily used for local development and testing.  On debug builds I may short-circuit normal application behavior to improve testability, whether executed from qtcreator or stand-alone.  I may for example disable external config files and give the application a default config and set of fixed data to easily test with, or add api's to facilitate testing automation.  These features and behaviors are then stripped from release builds.

I may produce binary installers out of **release** builds by using an alternative make target.  These alternate targets make it easy to use a release build for local testing (such as using the **publish_and_install** target in Archive.pri), and to hand off self-contained builds for testing by others.  Actual formal **release** builds are also commonly made with the **publish_and_archive** or the **publish_and_install** target to build binaries and release installers.  Source tarballs are produced with each publish target to make it easy to share and redistribute our software in original or modified form using the GNU GPL.

Coding and Resources
====================

To better support cross-platform desktops, I make use of per-platform style sheets to do small adjustments in spacing and style where needed.  The default cross-platform icon set and artwork are my own locally produced, and were designed and adjusted specifically to also render sharply when scaled at 16 and 24 pt sizes, as well as providing matching hidpi icons.  I chose glyph style icons for use on windows and mac, largely because they were the easiest to make, and use themed icons on GNU/Linux and other platforms where supported.

I have also standardized multi-language localization for my desktop applications.  A .ts file for each language will be kept in the translate/ directory, and .qm files will be auto-generated by qmake on the build host using lrelease.  For Mac, the .qm files are copied into the application resource fork.  On Windows, a translations subdirectory is used, and on generic unix platforms, a shared translation data directory is used.

I make use of Qt pri's to better segment the codebase when used from QtCreator.  This makes it easier to gather common functionality together and provide structure to the overall project without having to segment the package into static libraries or lots of subdirectories.  It also makes for easy isolation and re-use of source components directly.

I try to use Qt 5.x style signal-slots exclusively in TextSeeker, and have chosen to generally standardize around c++11 in all my newer c++ applications.  I also make use of Qt style naming conventions in my code.  While it is often easy, and sloppy, to use defines to avoid accidental recursive includes, I also choose to make and use headers without this now, at least when they are not likely to be shared with external projects thru libraries.

Platform Specific Issues
========================

For both Windows and MacOS platforms I presume the Digia online installer will be used to install Qt itself, rather than working with ports (such as macports) or self-built configurations.  I will then bundle the Digia Qt runtimes for application deployment (using windeplyqt & macdeplyqt).  If I need to create additional frameworks, plugins, and other dependencies for those platforms, they will be initially installed in the Digia Qt installation directories first.  This seemed simpler for managing Qt development on those platforms.  

On MacOS I will produce desktop applications as application bundles, and any additional libraries I may provide for use with Qt will be distributed as frameworks as well.  On GNU/Linux I use the distro version (for BSD, the ports collection version) of Qt, with both applications and any additional libraries installed in standard /usr paths by default.  On GNU/Linux and BSD I also use XDG standards for setting desktop menus.  On GNU/Linux I will use standard distro packaging (debian, rpm, etc) to make installable applications, and on both GNU/Linux and BSD the original source tarballs may also be directly used to produce and install my applications.  In the case of Windows, I will typically provide applications with an INNO Setup generated installer.

On MacOS one should also be able to directly use macports or homebrew, and the versions of Qt included with those.  I auto-detect such uses based on the Qt prefix directory.  When using macports or homebrew or similar, I do not create application bundles and instead the build follows normal unix conventions.


Project Planning
================

Official project planning is performed on the gitlab [textseeker](https://gitlab.com/tychosoft/textseeker) project.  I will be using the issue tracking system and kanban style issue boards offered there.  All issues will be added to the backlog there, with what they call milestones and sprints being interchangeable. 

I have standardized use of tags for issues in gitlab for project planning. This includes "RC" for "release critical" issues, "hotfix" for bugs that may require an immediate release, "bugs" to distinguish bug issues from feature branches, and "blocked" to indicate some issue is currently blocked from further work. Standard tags can be found at gitlab [Tychosoft Tags](https://gitlab.com/groups/tychosoft/labels).

Merges and Versioning
=====================

Feature branches should be created thru and named by the issue tracker directly.  This facilitates auto-closure on merge in gitlab.  Generally a collection of issues will be gathered together and put on a milestone for development and inclusion in the next x.Y.0 release.  All changes will be made on an issue branch taken from master, and merged back to master.  This of course is the normal gitlab issue flow.

While an active milestone sprint is underway any high priority fixes will be merged back to master immediately, and then cherry-picked into a hotfix-a.b
branch as needed for a hotfix a.b.Z release.  Non-priority feature branches may not get merged until the end of the milestone sprint.  If there is no active milestone sprint underway, then any priority bugfix will be merged back to master and directly released as a point release as needed.

In addition to merge requests, a few things are done directly on master.  Tagging will typically happen from master, unless it is done for a hotfix patch release.  The changelog and version updates in the sources will happen as a direct commit to master.  Sometimes other packaging/release process issues will happen as direct commits on master as well.

Changelogs
==========

For a long time I have used an automated script for producing changelogs.  This uses the summary line of the merge request.  This makes it important to create a relevant summary title for the merge request that is clear and concise.
